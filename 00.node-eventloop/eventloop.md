memory allocation

函数是组合相关功能单元的方式

调用栈 函数嵌套调用会增加栈的深度
Javascript不对贯穿应用的整个生命周期的单个调用栈的运行做限制。
Javascript通过事件循环来处理同时执行多个任务的情况(并发)。事件循环可将其看作是一个无限运行的循环，它会不断地检查是否有待执行的工作，当发现有工作要执行时立即启动任务(使用调用栈来调用函数)。当函数执行完毕后，它会挂起，直到更多的任务到来。注意事件循环检查是否有更多的任务要做，只会在函数调用栈完成后去检查，而不是在执行每条指令完成后去检查。
一个耗时函数会阻塞事件循环，会导致事件循环无法处理接下来的任务。

JavaScript应用大都以单线程方式运行，不会同时存在多个调用栈(即函数不能并行执行)。需要通过以某种方式同时运行应用程序的多个副本，以允许应用程序扩展。主要的方式有：

- 使用cluster模块传入的HTTP请求路由到不同的应用实例
- 使用worker_threads模块在多个线程中运行JavaScript实例
- 使用child_process模块来衍生和管理多个进程

每个JavaScript环境都有自己独立的全局环境，并且不能在它们之间共享对象引用。

消息传递是通过在独立的线程之间共享对象或数据的某种序列化表示来实现的。

通过worker_threads可以在两个不同的JavaScript实例之间共享内存。可以通过创建ShareArrayBuffer实例，并且使用与工作线程消息传递相同的postMessage(value)方法将其从一个线程传递到另外一个线程来完成。
这个过程会产生一个字节数组，两个线程可以同时对其进行读写。序列化和反序列化数据时，消息传递会产生开销。这在支持适当的多线程语言中是不应该存在的，因为对象可以直接共享。

事件轮询是Node.js处理非阻塞I/O操作的机制。

Javascript正在从单线程向多线程语言过渡。Atomics对象提供了一种机制来协调不同线程之间的通信，而ShareArrayBuffer的实例可以垮线程读写。

异步运行 使用新的执行栈调用另外一个函数
同步运行 在同一个执行栈中执行另外一个函数

Node.js本身是多线程的，提供了操作系统抽象和IO的libuv,以及执行Javascript的V8引擎和其他内置的绑定模块

Node.js事件循环的各个阶段
轮询(I/O相关回调,主程序代码) -> 检查(setImmediate触发的回调) -> 关闭 (EventEmitter的close事件触发的回调) -> 定时器(setTimeout/setInterval调度的回调) -> 挂起(特殊的系统事件触发的回调)
每个阶段都维护一个要执行的回调队列。回调根据应用程序的使用方式处在不同的阶段。
两个特殊的微任务队列，它们可以在某个阶段运行添加回调。一个微任务处理process.nextTick()注册的回调，另微任务队列处理resolve或reject的Promise。`微任务队列中的回调优于各阶段正常队列中的回调，微任务队列的下一个循环(tick)中的回调在Promise微任务队列中的回调之前运行`。

应用程序开始运行时，也会启动事件循环，并每次处理一个阶段。Node.js在应用程序运行时适当地向不同队列添加回调。当事件循环到达某个阶段时，它将运行该阶段队列中的所有回调。一旦给定阶段中的所有回调都运行完毕，事件循环就会转入下一个阶段。如果应用程序执行完所有要做的事情，但仍在等待I/O操作完成，那么它将在轮询阶段挂起。
